#Praser [![Build Status](https://travis-ci.org/hacatu/Praser.svg?branch=master)](https://travis-ci.org/hacatu/Praser)

Praser is a C library for creating parsers, usually ll[k] but optionally 
recursive descent.  Parsers return a parse tree, which is just an n-ary 
tree where each node has a string tag.  Several demo parsers are included,
such as `calculator_parser`, `tree_parser`, and `lisp_parsr`.

The current API offers a lot of functions for combining parsers into more
complicated parsers and for iterating over parse trees and extracting values.

##Building Praser

Praser uses [SCons](www.scons.org "www.scons.org") as its build system, so to install Praser, you must have SCons.

###Installing SCons

* Linux

    Try to install SCons from your package manager.  If you can't, try the .tar.gz file from
[www.scons.org](www.scons.org "www.scons.org").  Downloade and extract it, and then open a terminal in the folder it is in.
Then do `sudo python setup.py install`.  You probably already have Python if you are using Linux, but check by
entering `python` into a terminal if you don't know.

* Windows

    Install SCons from [www.scons.org](www.scons.org "www.scons.org").  Just open the link, go to downloads, and pick the
scons ... setup.exe. You will need to have [Python](www.python.org "www.python.org"), which you can download from
that link.  You will also need to add Python to your path, so keep note of where you install it and add it by going to
control panel and searching for "path".  I should add pre built Windows binaries for 32 and 64 bit when I release version
1.0.

* Mac

    If you have a package manager, try to install SCons from there.  If you don't, download and install the .tar.gz file
as explained in the Linux instructions above.  You definitely already have Python though.

###Installing a C compiler

This only applies to Windows, Linux and Mac come with C compilers.  You can either use Microsoft Visual C++ (msvc), or
MinGW.  Currently, I only have instructions for msvc.  Download it from
[www.visualstudio.com](www.visualstudio.com "www.visualstudio.com").  There is a good free version available called
Visual Studio Community; do not pay for it or download Visual Studio Express.

###Building Praser

1. Download this repository, either using git if you have it ( `git pull https://github.com/hacatu/Praser` ) or by
downloading the zip from the github page.

1. Open a terminal in the folder you downloaded the repository into.  This folder should have LICENSE.txt, readme.md
SConstruct, and src in it, as well as files starting with a . if you have Windows.  In the terminal run `scons demos=1`,
which will build the library and demos.  If you do not have `demos=1`, only the library will be built.

1. To install the library as well, add `/usr install=/usr` for Mac or Linux.  The first `/usr` tells SCons it is ok to
install in /usr or any subfolder, this should be the same as the second path.  For Windows, you would probably be best off
adding the `lib` folder generated by SCons to your include and link paths in the Visual Studio options.  You could also
set `install` to _Visual C++ root folder_, but I don't recommend it.

##Using the Praser libraries

1. In your source code `#include` the appropriate files from the library.  "parser.h" and "ptree.h" are the two headers
for the main library, and the utilities library also has "spawn_process.h", but you should probably not use this since it
is written for the specific use case in `parser_repl`, "stack.h", but you should probably not use this since your
Operating System probably has a better version, "get_line.h", and "debug.h".  Include the ones of these you need.

1. When you compile, there are three ways you can get the files linked properly:

	1. Put every file you include in the same folder as the file that includes it.  Also put the library files in the same
	folder and link to them simply by adding them to your compiler's inputs.  For this method, the include should be
	in "" not <>.  _THIS IS A TERRIBLE WAY TO DO IT_
	
	2. Add -I _folder with headers_ to the compiling step and -L _folder with libraries_ -lparser -lparser_util.
	The include should be in <> not "".  This is much better, and is the way you should build if you do not want to install
	Praser to the system.  Note: -I, -L, and -l are /I, /L, and/l in Windows.  You can also add these folders to the right
	paths if you have an IDE like Eclipse or Visual Studio.
	
	3. Add the headers to /usr/include or _Visual C++ root folder_ \\\\VC\\\\Include and the libraries to /usr/lib or
	_Visual C++ root folder_ \\\\VC\\\\Lib.  This is what adding `install` does when building Praser.  This is better than
	2 for Linux and Mac, but for Windows I would use 2.

*****

Here is a list of all the functions currently in the library:

`parser.h` functions:

* `int accept(Position *p, Ptree *t, AppendMode a, parser parse);`

    Trys a `parser` on the current `Position` and returns 1 on success and 0 on failure.
`parser` is a `typedef` for `int (*)(Position*, Ptree*)`
`AppendMode` changes how the output `Ptree` is handled.  It can be `ADD` to add the
`Ptree` generated by the `parser` to the input `Ptree`, `JOIN` to join them together by
combining the text tags and child nodes, or `SKIP` to ignore the output.  Note that
if the `parser` fails, the `Position` is NOT reset.  For that, see the `try` function.

* `char acceptEnd(Position *p);`

    Tests if a `Position` is the final possible `Position`.  For a string, this is the
null terminator.

* `int acceptString(Position *p, Ptree *t, AppendMode a, const char *s);`

    Consumes a string (`const char *s`) from the input and returns 1 on success, 0 on
failure.  This is one of the few functions which does parsing and is not a parser
combinator.

* `int alternate(Position *p, Ptree *t, AppendMode aA, AppendMode aB, parser parseA, parser parseB);`

    Takes two `parser`s, a and b, and acts as a `parser` that consumes a then b then a then b then ...
and so on for as long as it can.  It will append the outputs of both as dictated by the `AppendMode`s
aA and aB.  This function is basically how you would implement a comma seperated list:
`alternate(p, t, ADD, SKIP, parse_element, parse_comma);` where `parse_element` and `parse_comma` are
defined above somewhere.

* `char currentChar(Position *p);`

    Returns the current char.  Pretty basic.  Useful for switching if multiple possible things could follow
what is being parsed, because testing using lookahead via `currentChar` and `nextChar` and `nthChar`
is better than backtracking using `try`.

* `Position *firstPosition(const char *string);`

    Creates a `Position` at the beginning of a string.  Currently there is no equivalent function for files,
but it is on the TODO list.

* `char getChar(Position *p);`

    Returns the current char and then advances the `Position` to the next char.  This is mostly depreciated;
a parser of some kind should always be used to accept input.

* `void logUnexpectedError(Position *p, const char *name, const char *expected);`

    Prints an error message for those times when the input sequence is is invalid.

* `char nextChar(Position *p);`

    Returns the next char.  Useful for lookahead.

* `int noneOf(Position *p, Ptree *t, AppendMode a, const char *options);`

    Accepts one char not in the string `options`.

* `int not(Position *p, Ptree *t, AppendMode a, parser parse);`

    Accepts one char if the parser does not match.  This function WILL return to the start if the parser
consumes some input but fails.

* `char nthChar(Position *p, int n);`

    Returns the char n spaces after the current position.  Useful for lookahead.

* `int oneOf(Position *p, Ptree *t, AppendMode a, const char *options);`

    Accepts one char in the string `options`.

* `int repeat(Position *p, Ptree *t, AppendMode a, parser parse, int min, int max);`

    Accepts one parser repeated between min and max times.  If min and max are an invalid range (min > max or either <= 0),
there is no upper bound.  If the upper bound is reached, `repeat` stops and returns success.

* `int sepBy(Position *p, Ptree *t, AppendMode a, AppendMode aSeperator, parser parse, parser parseSeperator, int min, int max);`

    Accepts `parse` seperated by `parserSeperator`.  An example use is 1,2,3 (numbers seperated by commas).  Here,
1,2,3, or ,1,2,3, or ,1,2,3 would not work.

* `int try(Position *p, Ptree *t, AppendMode a, parser parse);`

    `try` is exactly like `accept` except it reverts the `Position` if the `parser` fails.

***

`parser.h` pre built parsers

* `void setString(Ptree *p, const char *string, int length);`

    Accepts a single character in single quotes.  Escapes are not currently supported.

* `int cstring(Position *p, Ptree *t);`

    Accepts a string in double quotes.  Escapes are not currently supported.  No prefixes or suffixes such as "r"
are supported.

* `int digit(Position *p, Ptree *t);`

    Accepts a single decimal digit.

* `int integer(Position *p, Ptree *t);`

    Accepts a decimal integer.  No suffixes such as "l" are supported.

* `int letter(Position *p, Ptree *t);`

    Accepts a single uppercase or lowercase letter from a-z.

* `int spaces(Position *p, Ptree *t);`

    Accepts whitespace.

***

`ptree.h` functions

* `void appendString(Ptree *p, const char *string, int length);`

    Appends a given string to the string already in a `Ptree`.  `length` is required.

* `Ptree *copyPtree(const Ptree *t);`

    Creates an exact duplicate of a `Ptree`.  If `copyPtree` returns null, it was unable to allocate memory.

* `void deletePtree(Ptree *t);`

    Deletes all children of a `Ptree` and frees its pointers.  The `Ptree` this is called on still needs
to be freed if it was dynamically allocated.

* `Ptree *firstPostorder(Ptree *root);`

    Finds and returns the first element of a `Ptree` in a postorder traversal.

* `void flatten(Ptree *t);`

    `flatten` deletes all nodes that only have one child and replace them with their child.  This allows parsers
to be nested a lot but the `Ptree` to still be relatively flat.

* `void flattenTagged(Ptree *t);`

    This is the same as `flatten` except that it keeps nodes that only have one child if that child has no children
or more than one child.  This is useful for having the parser set a tag to the type of a node and then set its child's
tag to the value, like the parent's string is `"(string)"` and the child's is `"Hello world!"`.

* `int getLength(const Ptree *t);`

    Gets the length of a `Ptree`'s string.

* `int getSize(const Ptree *t);`

    Gets the size of a `Ptree`, ie how many child nodes it has.

* `int getString(const Ptree *t);`

    Gets the string tag of a `Ptree`.

* `char isTerminal(const Ptree *t);`

    Returns 1 if a `Ptree` has no children and 0 otherwise.

* `Ptree *lastChild(Ptree *t);`

    Returns the last child of a `Ptree`.  `lastChild(t)` is the same as `nthChild(t, -1)` or `nthChild(t, getSize(t) - 1)`

* `void logMemoryError(const char *name);`

    Helps programs complain about running out of memory.

* `Ptree *mallocPtree();`

    Returns a pointer to a `Ptree` or a null pointer on failure.  `mallocPtree()` is the same as `malloc(sizeof(Ptree))`
except that `Ptree` is not defined in the header so its size is unknown to you if you have set up your includes properly.

* `Ptree *nextPostorder(Ptree *current);`

    Returns the next node in a postorder traversal, or null if there is not a next node.  This is useful for iterating
over `Ptree`s: set a `Ptree` pointer `current` to `firstPostorder(root)` and then process it, set it to
`nextPostorder(current)` and repeat.

* `Ptree *nthChild(const Ptree *t, int n);`

    Returns the nth child of a `Ptree`.  Supports negative indexes like `nthChild(t, -i)` is the same as
`nthChild(t, getSize(t) - i)`.  If the index is out of bounds, it will return null.

* `Ptree *parent(Ptree *t);`

    Returns the parent `Ptree` of a `Ptree`, which is null for the root `Ptree`.

* `void printPtree(const Ptree *t, int indent);`

    Prints a `Ptree` indented `indent` spaces.  `indent` is incremented once per nested node that gets printed,
and there is no need to print a new line at the end since this happens automatically.

* `void setString(Ptree *p, const char *string, int length);`

    Sets the string for a `Ptree`.

